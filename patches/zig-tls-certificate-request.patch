--- a/lib/std/crypto/tls/Client.zig
+++ b/lib/std/crypto/tls/Client.zig
@@ -327,6 +327,7 @@
     var handshake_cipher: tls.HandshakeCipher = undefined;
     var main_cert_pub_key: CertificatePublicKey = undefined;
     var tls12_negotiated_group: ?tls.NamedGroup = null;
+    var client_cert_requested = false;
     const now_sec = options.realtime_now_seconds;

     var cleartext_fragment_start: usize = 0;
@@ -593,6 +594,22 @@
                         }
                         handshake_state = .certificate;
                     },
+                    .certificate_request => {
+                        // TLS 1.3 CertificateRequest: server asks for client cert.
+                        // We don't support client certificates, but must include
+                        // the message in the transcript and respond with an empty
+                        // Certificate message later (in the .finished handler).
+                        if (tls_version != .tls_1_3) return error.TlsUnexpectedMessage;
+                        if (cipher_state != .handshake) return error.TlsUnexpectedMessage;
+                        if (handshake_state != .certificate) return error.TlsUnexpectedMessage;
+                        switch (handshake_cipher) {
+                            inline else => |*p| p.transcript_hash.update(wrapped_handshake),
+                        }
+                        // Skip the CertificateRequest body (context + extensions).
+                        // handshake_state stays .certificate so the server's
+                        // Certificate message is processed next.
+                        client_cert_requested = true;
+                    },
                     .certificate => cert: {
                         if (cipher_state == .application) return error.TlsUnexpectedMessage;
                         switch (handshake_state) {
@@ -825,6 +842,24 @@
                                     p.transcript_hash.update(wrapped_handshake);
                                     const expected_server_verify_data = tls.hmac(P.Hmac, &finished_digest, pv.server_finished_key);
                                     if (!std.crypto.timing_safe.eql([P.Hmac.mac_length]u8, expected_server_verify_data, hsd.array(P.Hmac.mac_length).*)) return error.TlsDecryptError;
+
+                                    // Application traffic secrets use Hash(CH..SF)
+                                    // BEFORE any client Certificate/Finished.
+                                    const app_handshake_hash = p.transcript_hash.peek();
+
+                                    // Empty Certificate handshake message for client cert response.
+                                    const empty_cert_hs: [8]u8 = .{
+                                        @intFromEnum(tls.HandshakeType.certificate),
+                                        0, 0, 4, // handshake length = 4
+                                        0, // certificate_request_context length = 0
+                                        0, 0, 0, // certificate_list length = 0
+                                    };
+                                    // Include empty cert in transcript if server requested it.
+                                    // Client Finished verify_data uses Hash(CH..SF + client_Cert).
+                                    if (client_cert_requested) {
+                                        p.transcript_hash.update(&empty_cert_hs);
+                                    }
+
                                     const handshake_hash = p.transcript_hash.finalResult();
                                     const verify_data = tls.hmac(P.Hmac, &handshake_hash, pv.client_finished_key);
                                     const out_cleartext = .{@intFromEnum(tls.HandshakeType.finished)} ++
@@ -838,20 +873,46 @@
                                         array(u16, u8, @as([wrapped_len]u8, undefined));

                                     const ad = finished_msg[0..tls.record_header_len];
-                                    const ciphertext = finished_msg[tls.record_header_len..][0..out_cleartext.len];
+                                    const ciphertext_slice = finished_msg[tls.record_header_len..][0..out_cleartext.len];
                                     const auth_tag = finished_msg[finished_msg.len - P.AEAD.tag_length ..];
-                                    const nonce = pv.client_handshake_iv;
-                                    P.AEAD.encrypt(ciphertext, auth_tag, &out_cleartext, ad, nonce, pv.client_handshake_key);

-                                    var all_msgs_vec: [2][]const u8 = .{
-                                        &client_change_cipher_spec_msg,
-                                        &finished_msg,
-                                    };
-                                    try output.writeVecAll(&all_msgs_vec);
+                                    if (client_cert_requested) {
+                                        // Encrypt and send empty Certificate as record #0.
+                                        const cert_inner = empty_cert_hs ++ .{@intFromEnum(tls.ContentType.handshake)};
+                                        const cert_wrapped_len = cert_inner.len + P.AEAD.tag_length;
+                                        var cert_msg = .{@intFromEnum(tls.ContentType.application_data)} ++
+                                            int(u16, @intFromEnum(tls.ProtocolVersion.tls_1_2)) ++
+                                            array(u16, u8, @as([cert_wrapped_len]u8, undefined));
+                                        const cert_ad = cert_msg[0..tls.record_header_len];
+                                        const cert_ct = cert_msg[tls.record_header_len..][0..cert_inner.len];
+                                        const cert_tag = cert_msg[cert_msg.len - P.AEAD.tag_length ..];
+                                        P.AEAD.encrypt(cert_ct, cert_tag, &cert_inner, cert_ad, pv.client_handshake_iv, pv.client_handshake_key);
+
+                                        // Finished is record #1: nonce = IV XOR 1.
+                                        var finished_nonce: [P.AEAD.nonce_length]u8 = pv.client_handshake_iv;
+                                        finished_nonce[P.AEAD.nonce_length - 1] ^= 1;
+                                        P.AEAD.encrypt(ciphertext_slice, auth_tag, &out_cleartext, ad, finished_nonce, pv.client_handshake_key);
+
+                                        var all_msgs_vec: [3][]const u8 = .{
+                                            &client_change_cipher_spec_msg,
+                                            &cert_msg,
+                                            &finished_msg,
+                                        };
+                                        try output.writeVecAll(&all_msgs_vec);
+                                    } else {
+                                        const nonce = pv.client_handshake_iv;
+                                        P.AEAD.encrypt(ciphertext_slice, auth_tag, &out_cleartext, ad, nonce, pv.client_handshake_key);
+
+                                        var all_msgs_vec: [2][]const u8 = .{
+                                            &client_change_cipher_spec_msg,
+                                            &finished_msg,
+                                        };
+                                        try output.writeVecAll(&all_msgs_vec);
+                                    }
                                     try output.flush();

-                                    const client_secret = hkdfExpandLabel(P.Hkdf, pv.master_secret, "c ap traffic", &handshake_hash, P.Hash.digest_length);
-                                    const server_secret = hkdfExpandLabel(P.Hkdf, pv.master_secret, "s ap traffic", &handshake_hash, P.Hash.digest_length);
+                                    const client_secret = hkdfExpandLabel(P.Hkdf, pv.master_secret, "c ap traffic", &app_handshake_hash, P.Hash.digest_length);
+                                    const server_secret = hkdfExpandLabel(P.Hkdf, pv.master_secret, "s ap traffic", &app_handshake_hash, P.Hash.digest_length);
                                     if (options.ssl_key_log) |key_log| logSecrets(key_log.writer, .{
                                         .counter = key_seq,
                                         .client_random = &client_hello_rand,
@@ -921,7 +982,16 @@
                             .ssl_key_log = options.ssl_key_log,
                         };
                     },
-                    else => return error.TlsUnexpectedMessage,
+                    else => {
+                        std.log.err("TLS: unexpected handshake_type={d} (0x{x:0>2}) handshake_len={d} cipher_state={any} handshake_state={any}", .{
+                            @intFromEnum(handshake_type),
+                            @intFromEnum(handshake_type),
+                            handshake_len,
+                            cipher_state,
+                            handshake_state,
+                        });
+                        return error.TlsUnexpectedMessage;
+                    },
                 }
                 if (ctd.eof()) break;
                 cleartext_fragment_start = ctd.idx;
